// @file:     phys_engine.cc
// @author:   Samuel
// @created:  2018.02.06
// @editted:  2017.02.06 - Samuel
// @license:  GNU LGPL v3
//
// @desc:     C++ wrapper that interfaces with db-sim and calls the Python scripts
//            for the AFMMarcus simulator

#include "afm_marcus.h"

#include <boost/filesystem.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>

using namespace phys;

// constructor
AFMMarcus::AFMMarcus(const std::string &in_path, const std::string &out_path, const std::string &script_path, const std::string &temp_path)
  : PhysicsEngine("AFMMarcus", in_path, out_path, script_path, temp_path)
{
}

// run the simulation
bool AFMMarcus::runSim()
{
  std::cout << std::endl << "*** AFMMarcus: Entered simulation ***" << std::endl;
  // check if script exists at script_path
  // TODO

  // determine the paths for exporting the minimized problem to the script, and 
  // importing the results from the script
  std::string tmp_dir, script_problem_path, script_result_path;
  if (!tempPath().compare("")) {
    // use supplied temp path if available
    tmp_dir = tempPath();
  } else {
    // get current time formatted yyyymmdd-hhmmss
    const boost::posix_time::ptime curr_time = boost::posix_time::second_clock::local_time();
    boost::posix_time::time_facet* facet = new boost::posix_time::time_facet();
    facet->format("%Y%m%d-%H%M%S");
    std::stringstream ss;
    ss.imbue(std::locale(std::locale::classic(), facet));
    ss << curr_time;
    const std::string curr_time_str = ss.str();

    tmp_dir = boost::filesystem::temp_directory_path().string();
    tmp_dir += "/afm_marcus/" + curr_time_str;
    std::cout << "Temp directory = " << tmp_dir << std::endl;
  }
  boost::filesystem::create_directories(tmp_dir);
  script_problem_path = tmp_dir + "/afmmarcus_problem.xml";
  script_result_path = tmp_dir + "/afmmarcus_result.xml";

  // write the minimized problem to file with only the info required for python script
  // to understand the problem
  if (!exportProblemForScript(script_problem_path))
    return false;

  // setup command for invoking python script with the input and output file paths as 
  // arguments. NOTE might not work on Windows, look into PyRun_SimpleFile if necessary.
  std::string command = "python " + scriptPath() + " ";
  command += script_problem_path + " "; // problem path for the script to read
  command += script_result_path;        // result path that the script writes to

  // call the script. This is non-forking so current process will wait until it finishes
  system(command.c_str());

  // parse the outputs from the result file generated by the script
  if (!importResultFromScript(script_result_path))
    return false;

  // use writeResultXml in phys_engine to export the result, TODO with flags indicating
  // what is being written
  writeResultsXml();
  // TODO update phys_engine's writeResultXml to be able to output the results
  //      from this simulator

  std::cout << std::endl << "*** AFMMarcus: Simulation has completed ***" << std::endl;
  return true;
}


// PRIVATE

bool AFMMarcus::exportProblemForScript(const std::string &script_problem_path)
{
  // for AFMMarcus, only the following items are needed:
  //   AFM Path
  //   DB location in lattice units
  //   Other simulation parameters
  // TODO
  return false;
}

bool AFMMarcus::importResultFromScript(const std::string &script_result_path)
{

  return false;
}
